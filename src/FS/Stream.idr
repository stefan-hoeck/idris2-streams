module FS.Stream

-- ||| Emits the first value fulfilling the given predicate.
-- export
-- find : (o -> Bool) -> Stream f es o -> Stream f es o
-- find pred (S p) =
--   stream $ do
--     Just (v,_) <- find pred p | Nothing => pure ()
--     output1 v
--
-- ||| Chunk-wise folds all inputs using an initial
-- ||| value and supplied binary operator, and emits a single element stream.
-- export
-- foldChunk : p -> (p -> c o -> p) -> Stream_ c f es o -> Stream1 f es p
-- foldChunk v g (S p) = S $ foldChunk v g p >>= outputChunk
--
-- ||| Folds all inputs using an initial value and binary operator
-- export %inline
-- fold : p -> (p -> o -> p) -> Stream f es o -> Stream1 f es p
-- fold v = foldChunk v . foldl
--
-- ||| Accumulates all values in a stream as their sum.
-- export %inline
-- sum : Num o => Stream f es o -> Stream1 f es o
-- sum = fold 0 (+)
--
-- ||| Accumulates all values in a stream as their product.
-- export %inline
-- product : Num o => Stream f es o -> Stream1 f es o
-- product = fold 1 (*)
--
-- ||| Maps and accumulates the values in a stream via a `Monoid`.
-- |||
-- ||| Note: Unlike `appendMap`, this will always result in single-element stream
-- export
-- foldMap : Monoid p => (o -> p) -> Stream f es o -> Stream1 f es p
-- foldMap g = foldChunk neutral (\v,vs => v <+> foldMap g vs)
--
-- ||| Accumulates the values in a stream via a `Monoid`.
-- |||
-- ||| Note: Unlike `append`, this will always result in single-element stream
-- export
-- concat : Monoid p => Stream f es p -> Stream1 f es p
-- concat = foldChunk neutral (\v,vs => v <+> concat vs)
--
-- ||| Folds all inputs using the supplied binary operator,
-- ||| emitting a single-element stream, or the empty stream if
-- ||| the input is empty, or the never stream if the input is non-terminating.
-- export
-- fold1 : (o -> o -> o) -> Stream f es o -> Stream1 f es o
-- fold1 g (S p) = S $ fold1 g p >>= maybe (pure ()) outputChunk
--
-- ||| Emits the largest value found in a stream.
-- export %inline
-- maximum : Ord o => Stream f es o -> Stream1 f es o
-- maximum = fold1 max
--
-- ||| Emits the smallest value found in a stream.
-- export %inline
-- minimum : Ord o => Stream f es o -> Stream1 f es o
-- minimum = fold1 min
--
-- ||| Emits the number of values encountered
-- export %inline
-- count : Stream f es o -> Stream1 f es Nat
-- count = fold 0 (const . S)
--
-- ||| Maps and accumulates the values in a stream via a `Semigroup`.
-- |||
-- ||| Note: Unlike `concat`, this will return an empty stream if the input
-- |||       is empty.
-- export %inline
-- append : Semigroup o => Stream f es o -> Stream1 f es o
-- append = fold1 (<+>)
--
-- ||| Maps and accumulates the values in a stream via a `Semigroup`.
-- |||
-- ||| Note: Unlike `foldMap`, this will return an empty stream if the input
-- |||       is empty.
-- export %inline
-- appendMap : Semigroup p => (o -> p) -> Stream f es o -> Stream1 f es p
-- appendMap f = append . map f
--
-- ||| Emits `False` and halts as soon as a non-matching
-- ||| element is received; or emits a single `True` value if it
-- ||| reaches the stream end and every input before that matches the predicate;
-- ||| or hangs without emitting values if the input is
-- ||| infinite and all inputs match the predicate.
-- export
-- all : (o -> Bool) -> Stream f es o -> Stream1 f es Bool
-- all pred (S p) = stream $ all pred p >>= outputChunk
--
-- ||| Emits `Talse` and halts as soon as a non-matching
-- ||| element is received; or emits a single `False` value if it
-- ||| reaches the stream end and every input before that did not match
-- ||| the predicate; or hangs without emitting values if the input is
-- ||| infinite and all inputs do not match the predicate.
-- export
-- any : (o -> Bool) -> Stream f es o -> Stream1 f es Bool
-- any pred (S p) = stream $ any pred p >>= outputChunk
--
-- ||| Wraps the values emitted by this stream in a `Just` and
-- ||| marks its end with a `Nothing`.
-- export
-- endWithNothing : Stream f es o -> Stream f es (Maybe o)
-- endWithNothing s = map Just s <+> pure Nothing
--
-- --------------------------------------------------------------------------------
-- -- Scans
-- --------------------------------------------------------------------------------
--
-- export %inline
-- mapAccumulate :
--      (init: st)
--   -> (st -> o -> (st,p))
--   -> Stream f es o
--   -> Stream f es p
-- mapAccumulate init fun = scanChunk init (mapAccum [<] fun)
--
-- ||| Zips the input with a running total according to `s`, up to but
-- ||| not including the current element. Thus the initial
-- ||| `vp` value is the first emitted to the output:
-- export
-- zipWithScan : p -> (p -> o -> p) -> Stream f es o -> Stream f es (o,p)
-- zipWithScan vp fun =
--   mapAccumulate vp $ \vp1,vo =>
--     let vp2 := fun vp1 vo
--      in (vp2, (vo, vp1))
--
-- ||| Pairs each element in the stream with its 0-based index.
-- export %inline
-- zipWithIndex : Stream f es o -> Stream f es (o,Nat)
-- zipWithIndex = zipWithScan 0 (\n,_ => S n)
--
-- ||| Like `zipWithScan` but the running total is including the current element.
-- export
-- zipWithScan1 : p -> (p -> o -> p) -> Stream f es o -> Stream f es (o,p)
-- zipWithScan1 vp fun =
--   mapAccumulate vp $ \vp1,vo =>
--     let vp2 := fun vp1 vo
--      in (vp2, (vo, vp2))
--
-- ||| Zips each element of this stream with the previous element wrapped into `Some`.
-- ||| The first element is zipped with `None`.
-- export %inline
-- zipWithPrevious : Stream f es o -> Stream f es (Maybe o, o)
-- zipWithPrevious = mapAccumulate Nothing $ \m,vo => (Just vo, (m, vo))
--
--
-- ||| Emits the given separator between every pair of elements in the
-- ||| source stream.
-- export
-- intersperse : (sep : o) -> Stream f es o -> Stream f es o
-- intersperse sep (S p) =
--   S $ uncons1 p >>= \case
--     Left _      => pure ()
--     Right (h,t) => cons [h] (mapChunk (>>= \v => [sep,v]) t)
--
-- ||| Similar to `fold` but emits the currently accumulated state
-- ||| on every output.
-- export
-- scan : p -> (p -> o -> p) -> Stream f es o -> Stream f es p
-- scan ini f = mapAccumulate ini (\t,v => let next := f t v in (next,next))
--
-- ||| Emits a running total of the values emitted.
-- export %inline
-- runningTotal : Num o => Stream f es o -> Stream f es o
-- runningTotal = scan 0 (+)
--
-- ||| Emits a running count (starting at 1) of the number of values emitted.
-- export %inline
-- runningCount : Stream f es o -> Stream f es Nat
-- runningCount = scan 0 (const . S)
--
-- --------------------------------------------------------------------------------
-- -- Zipping Streams
-- --------------------------------------------------------------------------------
--
-- 0 ZipWithLeft : (List Type -> Type -> Type) -> List Type -> (i,o : Type) -> Type
-- ZipWithLeft f es i o = List i -> Pull f i es () -> Pull f o es ()
--
-- %inline
-- adjLeg :
--      (Pull_ c f o es () -> Pull_ d f p es ())
--   -> StepLeg c f es o
--   -> Pull_ d f p es ()
-- adjLeg f (SL p sc) = inScope sc (f p)
--
-- zipWithImpl :
--      ZipWithLeft f es o q
--   -> ZipWithLeft f es p q
--   -> (o -> p -> q)
--   -> Stream f es o
--   -> Stream f es p
--   -> Stream f es q
-- zipWithImpl k1 k2 fun (S os) (S ps) =
--   stream $ Prelude.do
--     sc           <- scope
--     Just (h1,t1) <- stepLeg (SL os sc) | Nothing => inScope sc (k2 [] ps)
--     Just (h2,t2) <- stepLeg (SL ps sc) | Nothing => adjLeg (k1 h1) t1
--     go h1 h2 t1 t2
--
--   where
--     go :
--          List o
--       -> List p
--       -> StepLeg List f es o
--       -> StepLeg List f es p
--       -> Pull f q es ()
--     go h1 h2 t1 t2 =
--       assert_total $ case zipImpl [<] fun h1 h2 of
--         Z cs => do
--           output cs
--           Just (h3,t3) <- stepLeg t1 | Nothing => adjLeg (k2 []) t2
--           Just (h4,t4) <- stepLeg t2 | Nothing => adjLeg (k1 h3) t3
--           go h3 h4 t3 t4
--         ZL os cs => do
--           output cs
--           Just (h4,t4) <- stepLeg t2 | Nothing => adjLeg (k1 os) t1
--           go os h4 t1 t4
--         ZR ps cs => do
--           output cs
--           Just (h3,t3) <- stepLeg t1 | Nothing => adjLeg (k2 ps) t2
--           go h3 ps t3 t2
--
-- ||| Zips the elements of two streams, combining them via the given binary
-- ||| function.
-- |||
-- ||| This terminates when the end of either branch is reached.
-- export %inline
-- zipWith : (o -> p -> q) -> Stream f es o -> Stream f es p -> Stream f es q
-- zipWith = zipWithImpl (\_,_ => pure ()) (\_,_ => pure ())
--
-- ||| Convenience alias for `zipWith MkPair`
-- export %inline
-- zip : Stream f es o -> Stream f es p -> Stream f es (o,p)
-- zip = zipWith MkPair
--
-- ||| Determinsitically zips elements with the specified function, terminating
-- ||| when the ends of both branches are reached naturally, padding the left
-- ||| branch with `pad1` and padding the right branch with `pad2` as necessary.
-- export %inline
-- zipAllWith :
--      (pad1 : o)
--   -> (pad2 : p)
--   -> (fund : o -> p -> q)
--   -> Stream f es o
--   -> Stream f es p
--   -> Stream f es q
-- zipAllWith vo vp fun =
--   zipWithImpl
--     (\ho,to => output (flip fun vp <$> ho) >> mapOutput (flip fun vp) to)
--     (\hp,tp => output (fun vo <$> hp) >> mapOutput (fun vo) tp)
--     fun
--
-- ||| Determinsitically zips elements, terminating when the ends of both branches
-- ||| are reached naturally, padding the left or right branch
-- ||| as necessary.
-- export %inline
-- zipAll : o -> p -> Stream f es o -> Stream f es p -> Stream f es (o,p)
-- zipAll vo vp = zipAllWith vo vp MkPair
--
-- ||| Deterministically interleaves elements, starting on the left,
-- ||| terminating when the end of either branch is reached naturally.
-- export %inline
-- interleave : Stream f es o -> Stream f es o -> Stream f es o
-- interleave xs ys = zip xs ys >>= \(x,y) => emits [x,y]
--
-- ||| Deterministically interleaves elements, starting on the left,
-- ||| terminating when the ends of both branches are reached naturally.
-- export
-- interleaveAll : Stream f es o -> Stream f es o -> Stream f es o
-- interleaveAll xs ys =
--   zipAll [] [] (map pure xs) (map pure ys) >>= \(l,r) => emits (l ++ r)
