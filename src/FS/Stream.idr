module FS.Stream

-- import public Control.Monad.MCancel
-- import public Control.Monad.Resource
-- import public Data.Linear.ELift1
-- import public FS.ChunkSize
-- import public FS.Scope
--
-- import Data.Linear.Deferred
-- import Data.Linear.Ref1
-- import Data.List
-- import Data.Maybe
-- import Data.Nat
-- import FS.Internal.Chunk
-- import FS.Pull
--
-- %default total
--
-- --------------------------------------------------------------------------------
-- -- Combinators
-- --------------------------------------------------------------------------------
--
-- ||| Emits the first `n` values of a stream
-- export %inline
-- take : Nat -> Stream f es o -> Stream f es o
-- take n = stream . ignore . take n . pull
--
-- ||| Emits the last `n` values of a stream
-- |||
-- ||| Note: The whole `n` values have to be kept in memory, therefore,
-- |||       the result will be emitted as a single chunk. Take memory
-- |||       consumption into account when using this for very large `n`.
-- export
-- takeRight : (n : Nat) -> (0 p : IsSucc n) => Stream f es o -> Stream f es o
-- takeRight n (S p) = S $ takeRight n p >>= output
--
-- ||| Emits values until the given predicate returns `False`.
-- export
-- takeWhile : (o -> Bool) -> Stream f es o -> Stream f es o
-- takeWhile pred = stream . ignore . takeWhile pred . pull
--
-- ||| Like `takeWhile` but also includes the first failure.
-- export %inline
-- takeThrough : (o -> Bool) -> Stream f es o -> Stream f es o
-- takeThrough pred = stream . ignore . takeThrough pred . pull
--
-- ||| Emits values until the first `Nothing` is encountered.
-- export
-- takeWhileJust : Stream f es (Maybe o) -> Stream f es o
-- takeWhileJust = stream . ignore . takeWhileJust . pull
--
-- ||| Drops `n` elements of the input, then echoes the rest.
-- export
-- drop : Nat -> Stream f es o -> Stream f es o
-- drop n (S p) = S $ drop n p >>= fromMaybe (pure ())
--
-- ||| Only keeps the first element of the input.
-- export %inline
-- head : Stream f es o -> Stream f es o
-- head = take 1
--
-- ||| Drops the first element of the input.
-- export %inline
-- tail : Stream f es o -> Stream f es o
-- tail = drop 1
--
-- ||| Drops values from a stream while the given predicate returns `True`,
-- ||| then echoes the rest.
-- export
-- dropWhile : (o -> Bool) -> Stream f es o -> Stream f es o
-- dropWhile pred (S p) = S $ dropWhile pred p >>= fromMaybe (pure ())
--
-- ||| Like `dropWhile` but also drops the first value where
-- ||| the predicate returns `False`.
-- export
-- dropThrough : (o -> Bool) -> Stream f es o -> Stream f es o
-- dropThrough pred (S p) = S $ dropThrough pred p >>= fromMaybe (pure ())
--
-- ||| Emits the first value fulfilling the given predicate.
-- export
-- find : (o -> Bool) -> Stream f es o -> Stream f es o
-- find pred (S p) =
--   stream $ do
--     Just (v,_) <- find pred p | Nothing => pure ()
--     output1 v
--
-- ||| Chunk-wise maps the values produced by a stream
-- export %inline
-- mapChunk : (c o -> d p) -> Stream_ c f es o -> Stream_ d f es p
-- mapChunk f = S . mapChunk f . pull
--
-- ||| Chunk-wise maps the values produced by a stream
-- export %inline
-- mapChunkEval : (c o -> f es (d p)) -> Stream_ c f es o -> Stream_ d f es p
-- mapChunkEval f = S . mapChunkEval f . pull
--
-- ||| Chunk-wise consumes the output, draining the given stream.
-- export %inline
-- sinkChunk : (c o -> f es ()) -> Stream_ c f es o -> Stream_ d f es p
-- sinkChunk f = S . sinkChunk f . pull
--
-- ||| Consumes the output one value at a time, draining the given stream.
-- |||
-- ||| See also `sinkChunks` for a potentially more efficient version.
-- export %inline
-- sink : (o -> f es ()) -> Stream f es o -> Stream f es p
-- sink f = S . sink f . pull
--
-- ||| Emits only inputs which match the supplied predicate.
-- export %inline
-- filter : (o -> Bool) -> Stream f es o -> Stream f es o
-- filter pred = S . filter pred . pull
--
-- ||| Emits only inputs which do not match the supplied predicate.
-- export %inline
-- filterNot : (o -> Bool) -> Stream f es o -> Stream f es o
-- filterNot pred = filter (not . pred)
--
-- ||| Emits only inputs for which the given function returns a `Just`
-- export %inline
-- mapMaybe : (o -> Maybe p) -> Stream f es o -> Stream f es p
-- mapMaybe = mapChunk . mapMaybe
--
-- ||| Emits the chunks of the input stream.
-- export %inline
-- chunks : Stream_ c f es o -> Stream1 f es (c o)
-- chunks = mapChunk id
--
-- ||| Alias for `s >>= eval . f`
-- export %inline
-- evalMap : (o -> f es p) -> Stream f es o -> Stream f es p
-- evalMap f s = s >>= eval . f
--
-- ||| Like `evalMap`, but operates on chunks for performance.
-- export
-- evalMapChunk : (c o -> f es (d p)) -> Stream_ c f es o -> Stream_ d f es p
-- evalMapChunk g = S . mapChunkEval g . pull
--
-- ||| Chunk-wise folds all inputs using an initial
-- ||| value and supplied binary operator, and emits a single element stream.
-- export
-- foldChunk : p -> (p -> c o -> p) -> Stream_ c f es o -> Stream1 f es p
-- foldChunk v g (S p) = S $ foldChunk v g p >>= outputChunk
--
-- ||| Folds all inputs using an initial value and binary operator
-- export %inline
-- fold : p -> (p -> o -> p) -> Stream f es o -> Stream1 f es p
-- fold v = foldChunk v . foldl
--
-- ||| Accumulates all values in a stream as their sum.
-- export %inline
-- sum : Num o => Stream f es o -> Stream1 f es o
-- sum = fold 0 (+)
--
-- ||| Accumulates all values in a stream as their product.
-- export %inline
-- product : Num o => Stream f es o -> Stream1 f es o
-- product = fold 1 (*)
--
-- ||| Maps and accumulates the values in a stream via a `Monoid`.
-- |||
-- ||| Note: Unlike `appendMap`, this will always result in single-element stream
-- export
-- foldMap : Monoid p => (o -> p) -> Stream f es o -> Stream1 f es p
-- foldMap g = foldChunk neutral (\v,vs => v <+> foldMap g vs)
--
-- ||| Accumulates the values in a stream via a `Monoid`.
-- |||
-- ||| Note: Unlike `append`, this will always result in single-element stream
-- export
-- concat : Monoid p => Stream f es p -> Stream1 f es p
-- concat = foldChunk neutral (\v,vs => v <+> concat vs)
--
-- ||| Folds all inputs using the supplied binary operator,
-- ||| emitting a single-element stream, or the empty stream if
-- ||| the input is empty, or the never stream if the input is non-terminating.
-- export
-- fold1 : (o -> o -> o) -> Stream f es o -> Stream1 f es o
-- fold1 g (S p) = S $ fold1 g p >>= maybe (pure ()) outputChunk
--
-- ||| Emits the largest value found in a stream.
-- export %inline
-- maximum : Ord o => Stream f es o -> Stream1 f es o
-- maximum = fold1 max
--
-- ||| Emits the smallest value found in a stream.
-- export %inline
-- minimum : Ord o => Stream f es o -> Stream1 f es o
-- minimum = fold1 min
--
-- ||| Emits the number of values encountered
-- export %inline
-- count : Stream f es o -> Stream1 f es Nat
-- count = fold 0 (const . S)
--
-- ||| Maps and accumulates the values in a stream via a `Semigroup`.
-- |||
-- ||| Note: Unlike `concat`, this will return an empty stream if the input
-- |||       is empty.
-- export %inline
-- append : Semigroup o => Stream f es o -> Stream1 f es o
-- append = fold1 (<+>)
--
-- ||| Maps and accumulates the values in a stream via a `Semigroup`.
-- |||
-- ||| Note: Unlike `foldMap`, this will return an empty stream if the input
-- |||       is empty.
-- export %inline
-- appendMap : Semigroup p => (o -> p) -> Stream f es o -> Stream1 f es p
-- appendMap f = append . map f
--
-- ||| Emits `False` and halts as soon as a non-matching
-- ||| element is received; or emits a single `True` value if it
-- ||| reaches the stream end and every input before that matches the predicate;
-- ||| or hangs without emitting values if the input is
-- ||| infinite and all inputs match the predicate.
-- export
-- all : (o -> Bool) -> Stream f es o -> Stream1 f es Bool
-- all pred (S p) = stream $ all pred p >>= outputChunk
--
-- ||| Emits `Talse` and halts as soon as a non-matching
-- ||| element is received; or emits a single `False` value if it
-- ||| reaches the stream end and every input before that did not match
-- ||| the predicate; or hangs without emitting values if the input is
-- ||| infinite and all inputs do not match the predicate.
-- export
-- any : (o -> Bool) -> Stream f es o -> Stream1 f es Bool
-- any pred (S p) = stream $ any pred p >>= outputChunk
--
-- ||| Wraps the values emitted by this stream in a `Just` and
-- ||| marks its end with a `Nothing`.
-- export
-- endWithNothing : Stream f es o -> Stream f es (Maybe o)
-- endWithNothing s = map Just s <+> pure Nothing
--
-- --------------------------------------------------------------------------------
-- -- Scans
-- --------------------------------------------------------------------------------
--
-- ||| General stateful conversion of a `Streams`s output.
-- |||
-- ||| Aborts as soon as the given accumulator function returns `Nothing`
-- export
-- scanChunkMaybe :
--      st
--   -> (st -> Maybe (c o -> (d p,st)))
--   -> Stream_ c f es o
--   -> Stream_ d f es p
-- scanChunkMaybe s1 f = stream . ignore . scanChunkMaybe s1 f . pull
--
-- ||| Threads a stateful computation through all the chunks emitted by
-- ||| a stream, generating a final (possibly empty) chunk of values when
-- ||| the stream is exhausted.
-- export %inline
-- scanChunkFull :
--      (init : st)
--   -> (fun  : st -> c o -> (d p,st))
--   -> (end  : st -> d p)
--   -> Stream_ c f es o
--   -> Stream_ d f es p
-- scanChunkFull init fun end (S pl) =
--   S $ scanChunk init fun pl >>= outputChunk . end
--
-- ||| Like `scanChunksMaybe` but will transform the whole output.
-- export %inline
-- scanChunk :
--      (init: st)
--   -> (st -> c o -> (d p,st))
--   -> Stream_ c f es o
--   -> Stream_ d f es p
-- scanChunk init fun = S . ignore . scanChunk init fun . pull
--
-- export %inline
-- mapAccumulate :
--      (init: st)
--   -> (st -> o -> (st,p))
--   -> Stream f es o
--   -> Stream f es p
-- mapAccumulate init fun = scanChunk init (mapAccum [<] fun)
--
-- ||| Zips the input with a running total according to `s`, up to but
-- ||| not including the current element. Thus the initial
-- ||| `vp` value is the first emitted to the output:
-- export
-- zipWithScan : p -> (p -> o -> p) -> Stream f es o -> Stream f es (o,p)
-- zipWithScan vp fun =
--   mapAccumulate vp $ \vp1,vo =>
--     let vp2 := fun vp1 vo
--      in (vp2, (vo, vp1))
--
-- ||| Pairs each element in the stream with its 0-based index.
-- export %inline
-- zipWithIndex : Stream f es o -> Stream f es (o,Nat)
-- zipWithIndex = zipWithScan 0 (\n,_ => S n)
--
-- ||| Like `zipWithScan` but the running total is including the current element.
-- export
-- zipWithScan1 : p -> (p -> o -> p) -> Stream f es o -> Stream f es (o,p)
-- zipWithScan1 vp fun =
--   mapAccumulate vp $ \vp1,vo =>
--     let vp2 := fun vp1 vo
--      in (vp2, (vo, vp2))
--
-- ||| Zips each element of this stream with the previous element wrapped into `Some`.
-- ||| The first element is zipped with `None`.
-- export %inline
-- zipWithPrevious : Stream f es o -> Stream f es (Maybe o, o)
-- zipWithPrevious = mapAccumulate Nothing $ \m,vo => (Just vo, (m, vo))
--
--
-- ||| Emits the given separator between every pair of elements in the
-- ||| source stream.
-- export
-- intersperse : (sep : o) -> Stream f es o -> Stream f es o
-- intersperse sep (S p) =
--   S $ uncons1 p >>= \case
--     Left _      => pure ()
--     Right (h,t) => cons [h] (mapChunk (>>= \v => [sep,v]) t)
--
-- ||| Similar to `fold` but emits the currently accumulated state
-- ||| on every output.
-- export
-- scan : p -> (p -> o -> p) -> Stream f es o -> Stream f es p
-- scan ini f = mapAccumulate ini (\t,v => let next := f t v in (next,next))
--
-- ||| Emits a running total of the values emitted.
-- export %inline
-- runningTotal : Num o => Stream f es o -> Stream f es o
-- runningTotal = scan 0 (+)
--
-- ||| Emits a running count (starting at 1) of the number of values emitted.
-- export %inline
-- runningCount : Stream f es o -> Stream f es Nat
-- runningCount = scan 0 (const . S)
--
-- --------------------------------------------------------------------------------
-- -- Zipping Streams
-- --------------------------------------------------------------------------------
--
-- 0 ZipWithLeft : (List Type -> Type -> Type) -> List Type -> (i,o : Type) -> Type
-- ZipWithLeft f es i o = List i -> Pull f i es () -> Pull f o es ()
--
-- %inline
-- adjLeg :
--      (Pull_ c f o es () -> Pull_ d f p es ())
--   -> StepLeg c f es o
--   -> Pull_ d f p es ()
-- adjLeg f (SL p sc) = inScope sc (f p)
--
-- zipWithImpl :
--      ZipWithLeft f es o q
--   -> ZipWithLeft f es p q
--   -> (o -> p -> q)
--   -> Stream f es o
--   -> Stream f es p
--   -> Stream f es q
-- zipWithImpl k1 k2 fun (S os) (S ps) =
--   stream $ Prelude.do
--     sc           <- scope
--     Just (h1,t1) <- stepLeg (SL os sc) | Nothing => inScope sc (k2 [] ps)
--     Just (h2,t2) <- stepLeg (SL ps sc) | Nothing => adjLeg (k1 h1) t1
--     go h1 h2 t1 t2
--
--   where
--     go :
--          List o
--       -> List p
--       -> StepLeg List f es o
--       -> StepLeg List f es p
--       -> Pull f q es ()
--     go h1 h2 t1 t2 =
--       assert_total $ case zipImpl [<] fun h1 h2 of
--         Z cs => do
--           output cs
--           Just (h3,t3) <- stepLeg t1 | Nothing => adjLeg (k2 []) t2
--           Just (h4,t4) <- stepLeg t2 | Nothing => adjLeg (k1 h3) t3
--           go h3 h4 t3 t4
--         ZL os cs => do
--           output cs
--           Just (h4,t4) <- stepLeg t2 | Nothing => adjLeg (k1 os) t1
--           go os h4 t1 t4
--         ZR ps cs => do
--           output cs
--           Just (h3,t3) <- stepLeg t1 | Nothing => adjLeg (k2 ps) t2
--           go h3 ps t3 t2
--
-- ||| Zips the elements of two streams, combining them via the given binary
-- ||| function.
-- |||
-- ||| This terminates when the end of either branch is reached.
-- export %inline
-- zipWith : (o -> p -> q) -> Stream f es o -> Stream f es p -> Stream f es q
-- zipWith = zipWithImpl (\_,_ => pure ()) (\_,_ => pure ())
--
-- ||| Convenience alias for `zipWith MkPair`
-- export %inline
-- zip : Stream f es o -> Stream f es p -> Stream f es (o,p)
-- zip = zipWith MkPair
--
-- ||| Determinsitically zips elements with the specified function, terminating
-- ||| when the ends of both branches are reached naturally, padding the left
-- ||| branch with `pad1` and padding the right branch with `pad2` as necessary.
-- export %inline
-- zipAllWith :
--      (pad1 : o)
--   -> (pad2 : p)
--   -> (fund : o -> p -> q)
--   -> Stream f es o
--   -> Stream f es p
--   -> Stream f es q
-- zipAllWith vo vp fun =
--   zipWithImpl
--     (\ho,to => output (flip fun vp <$> ho) >> mapOutput (flip fun vp) to)
--     (\hp,tp => output (fun vo <$> hp) >> mapOutput (fun vo) tp)
--     fun
--
-- ||| Determinsitically zips elements, terminating when the ends of both branches
-- ||| are reached naturally, padding the left or right branch
-- ||| as necessary.
-- export %inline
-- zipAll : o -> p -> Stream f es o -> Stream f es p -> Stream f es (o,p)
-- zipAll vo vp = zipAllWith vo vp MkPair
--
-- ||| Deterministically interleaves elements, starting on the left,
-- ||| terminating when the end of either branch is reached naturally.
-- export %inline
-- interleave : Stream f es o -> Stream f es o -> Stream f es o
-- interleave xs ys = zip xs ys >>= \(x,y) => emits [x,y]
--
-- ||| Deterministically interleaves elements, starting on the left,
-- ||| terminating when the ends of both branches are reached naturally.
-- export
-- interleaveAll : Stream f es o -> Stream f es o -> Stream f es o
-- interleaveAll xs ys =
--   zipAll [] [] (map pure xs) (map pure ys) >>= \(l,r) => emits (l ++ r)
--
-- --------------------------------------------------------------------------------
-- -- Evaluating Streams
-- --------------------------------------------------------------------------------
--
-- parameters {0 f       : List Type -> Type -> Type}
--            {auto tgt  : Target s f}
--            {auto mcnc : MCancel f}
--
--   ||| Chunk-wise accumulates the values emitted by a stream.
--   export covering
--   accumChunk : (ini : a) -> (acc : a -> c o -> a) -> Stream_ c f es o -> f es a
--   accumChunk init acc (S p) =
--     weakenErrors (run (foldChunk init acc p)) >>= \case
--       Succeeded v => pure v
--       Error x     => fail x
--       Canceled    => pure init
--
--   ||| Accumulates the values emitted by a stream.
--   export covering %inline
--   accum : (init : a) -> (acc : a -> o -> a) -> Stream f es o -> f es a
--   accum init acc = accumChunk init (foldl acc)
--
--   ||| Accumulates the values emitted by a stream in a snoclist.
--   export covering %inline
--   toSnoc : Stream f es o -> f es (SnocList o)
--   toSnoc = accumChunk [<] (<><)
--
--   ||| Accumulates the values emitted by a stream in a list.
--   export covering %inline
--   toList : Stream f es o -> f es (List o)
--   toList = map (<>> []) . toSnoc
--
--   ||| Accumulates the values emitted by a stream in a list.
--   export covering %inline
--   toChunks : Stream_ c f es o -> f es (List $ c o)
--   toChunks = map (<>> []) . accumChunk [<] (:<)
--
--   ||| Runs an empty stream to completion.
--   export covering %inline
--   run : EmptyStream f es -> f es ()
--   run = accumChunk () (\_ => absurd)
